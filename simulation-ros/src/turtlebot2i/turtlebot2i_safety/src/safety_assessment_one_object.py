"""Making sure we are running the right version of python"""
import sys
if sys.version_info[0] >= 3:
    raise "Must be using Python 2"
""" later
# Python 2.x and 3.x compatibility
if sys.version_info[0] == 3:
    ...
else:
    # using Python 2.x, import and rename
    ...
""" 

import rospy # ROS library

#from nav_msgs.msg import Odometry
#from scene_graph.msg import SeceneGraph

#import message_filters
#from std_msgs.msg import String


import warnings
warnings.filterwarnings("ignore")  #  a lot of warning messages, but why?
import numpy as np
import skfuzzy as fuzz
from skfuzzy import control as ctrl



""" Main program """
if __name__ == "__main__":  
#-- RISK ASSESSMENT FLS INITIALIZATION-----------------------------------
    print("Initializing Risk Assessment FLS") 

    # New Antecedent/Consequent objects hold universe variables and membership functions
    object_distance = ctrl.Antecedent(np.arange(0, 3, 1), 'distance')     # 0- 3  meter
    object_direction  = ctrl.Antecedent(np.arange(0, 360, 1), 'direction') # 0-360 degree
    object_speed = ctrl.Antecedent(np.arange(0, 2, 1), 'speed')		#0- 2 m/s
    object_orientation = ctrl.Antecedent(np.arange(0, 360, 1), 'orientation')#0-360 degree

    risk = ctrl.Consequent(np.arange(0, 3, 1), 'risk')

    # Auto-membership function population is possible with .automf(3, 5, or 7) #poor,average,good
    object_distance.automf(3)   	# near, midium, far   
    object_direction.automf(3)	# left behind right 	#will be changed to custom MF
    object_speed.automf(3)		#slow medium fast
    object_orientation.automf(3)	# left behind right 	#will be changed to custom MF

    risk.automf(3) 

    '''
    # Custom membership functions can be built interactively with a familiar,
    # Pythonic API

    object_direction['front_1'] = fuzz.trimf(tip.universe, [0, 0, 45])
    object_direction['front_2'] = fuzz.trimf(tip.universe, [315, 315, 360])
    object_direction['front_left'] = fuzz.trimf(tip.universe, [0, 45, 90])
    object_direction['left'] = fuzz.trimf(tip.universe, [45, 90, 135])
    ...

    object_orientation['front_1'] = fuzz.trimf(tip.universe, [0, 0, 45])
    object_orientation['front_2'] = fuzz.trimf(tip.universe, [315, 315, 360])
    object_orientation['front_left'] = fuzz.trimf(tip.universe, [0, 45, 90])
    object_orientation['left'] = fuzz.trimf(tip.universe, [45, 90, 135])
    ...

    '''

    #Add Fuzzy rules
    #-----------
    #Rulls here are manually defined, but later it will be generated by MATLAB
    rule1 = ctrl.Rule(object_distance['poor'] | object_speed['good']| object_orientation['average'], risk['good'])
    rule2 = ctrl.Rule(object_direction['average'], risk['average'])
    rule3 = ctrl.Rule(object_distance['good'] | object_direction['good'] |object_direction['poor'], risk['poor'])




    #Control System Creation and Simulation
    #---------------------------------------
    #Now that we have our rules defined, we can simply create a control system

    risk_assessment_system = ctrl.ControlSystem([rule1, rule2, rule3]) # this is a FL system


    #In order to simulate this control system, we will create a instance (Call it Agent?)
    risk_assessment_instance = ctrl.ControlSystemSimulation(risk_assessment_system)  # this is a FLS instance
'''
#-- ROS SOAR NODE INITIALIZATION-----------------------------------    
    print("Initializing ROS RISK ASSESSMENT node")
    rospy.init_node("ra_ros_node",anonymous=True) #Always first
'''

    #We can now simulate our control system by simply specifying the inputs and calling the ``compute`` method.  
    # Pass inputs to the ControlSystem using Antecedent labels with Pythonic API
    # Note: if you like passing many inputs all at once, use .inputs(dict_of_data)
    risk_assessment_instance.input['distance'] = 1		# 0- 3  meter
    risk_assessment_instance.input['direction'] = 180	# 0-360 degree
    risk_assessment_instance.input['speed'] = 2		#0- 2 m/s
    risk_assessment_instance.input['orientation'] = 180	#0-360 degree


    # Crunch the numbers
    risk_assessment_instance.compute()

    """
    Once computed, we can view the result as well as visualize it.
    """

    print risk_assessment_instance.output['risk']
    #risk.view(sim=risk_assessment_instance) # a figure
 

    raw_input('Task finished!')  # If you use Python 2
    #input('Task finished!')      # If you use Python 3. But you should use Python 2 for the whole project.
