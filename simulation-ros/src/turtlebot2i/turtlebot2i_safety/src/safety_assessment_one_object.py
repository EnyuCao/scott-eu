import warnings
warnings.filterwarnings("ignore")
import numpy as np
import skfuzzy as fuzz
from skfuzzy import control as ctrl

# New Antecedent/Consequent objects hold universe variables and membership
# functions
object_distance = ctrl.Antecedent(np.arange(0, 3, 1), 'distance')     # 0- 3  meter
object_direction  = ctrl.Antecedent(np.arange(0, 360, 1), 'direction') # 0-360 degree
object_speed = ctrl.Antecedent(np.arange(0, 2, 1), 'speed')		#0- 2 m/s
object_orientation = ctrl.Antecedent(np.arange(0, 360, 1), 'orientation')#0-360 degree

risk = ctrl.Consequent(np.arange(0, 3, 1), 'risk')
# Auto-membership function population is possible with .automf(3, 5, or 7)  #poor,average,good
object_distance.automf(3)   	# near, midium, far   
object_direction.automf(3)	# left behind right 	#will be changed to custom MF
object_speed.automf(3)		#slow medium fast
object_orientation.automf(3)	# left behind right 	#will be changed to custom MF

risk.automf(3) 

'''
# Custom membership functions can be built interactively with a familiar,
# Pythonic API

object_direction['front_1'] = fuzz.trimf(tip.universe, [0, 0, 45])
object_direction['front_2'] = fuzz.trimf(tip.universe, [315, 315, 360])
object_direction['front_left'] = fuzz.trimf(tip.universe, [0, 45, 90])
object_direction['left'] = fuzz.trimf(tip.universe, [45, 90, 135])
...

object_orientation['front_1'] = fuzz.trimf(tip.universe, [0, 0, 45])
object_orientation['front_2'] = fuzz.trimf(tip.universe, [315, 315, 360])
object_orientation['front_left'] = fuzz.trimf(tip.universe, [0, 45, 90])
object_orientation['left'] = fuzz.trimf(tip.universe, [45, 90, 135])
...

'''

"""
Fuzzy rules
-----------

Rulls here are manually defined, but later it will be generated by MATLAB
"""

rule1 = ctrl.Rule(object_distance['poor'] | object_speed['good'], risk['good'])
rule2 = ctrl.Rule(object_direction['average'], risk['average'])
rule3 = ctrl.Rule(object_distance['good'] | object_direction['good'] |object_direction['poor'], risk['poor'])



"""
Control System Creation and Simulation
---------------------------------------

Now that we have our rules defined, we can simply create a control system
via:
"""

risk_assessment_system = ctrl.ControlSystem([rule1, rule2, rule3]) # this is a FL system

"""
In order to simulate this control system, we will create a instance
"""

risk_assessment_instance = ctrl.ControlSystemSimulation(risk_assessment_system)  # this is a FLS instance

"""
We can now simulate our control system by simply specifying the inputs
and calling the ``compute`` method.  Suppose we rated the quality 6.5 out of 10
and the service 9.8 of 10.
"""


# Pass inputs to the ControlSystem using Antecedent labels with Pythonic API
# Note: if you like passing many inputs all at once, use .inputs(dict_of_data)
risk_assessment_instance.input['distance'] = 1		# 0- 3  meter
risk_assessment_instance.input['direction'] = 180	# 0-360 degree
risk_assessment_instance.input['speed'] = 2		#0- 2 m/s
#risk_assessment_instance.input['orientation'] = 180	#0-360 degree


# Crunch the numbers
risk_assessment_instance.compute()

"""
Once computed, we can view the result as well as visualize it.
"""

print risk_assessment_instance.output['risk']
risk.view(sim=risk_assessment_instance)


raw_input('Task finished!')  # If you use Python 2
#input('Task finished!')      # If you use Python 3
